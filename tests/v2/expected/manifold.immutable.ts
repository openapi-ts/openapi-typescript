/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  readonly "/regions/": {
    readonly get: {
      readonly parameters: {
        readonly query: {
          /** Filter results to only include the regions that have this location. */
          readonly location?: string;
          /**
           * Filter results to only include the regions that are on this
           * platform.
           */
          readonly platform?: string;
        };
      };
      readonly responses: {
        /** A list of regions. */
        readonly 200: {
          readonly schema: readonly definitions["Region"][];
        };
        /** Unexpected Error */
        readonly 500: {
          readonly schema: definitions["Error"];
        };
      };
    };
    readonly post: {
      readonly parameters: {
        readonly body: {
          /** Region create request */
          readonly body: definitions["CreateRegion"];
        };
      };
      readonly responses: {
        /** Complete region object */
        readonly 201: {
          readonly schema: definitions["Region"];
        };
        /** Invalid request provided */
        readonly 400: {
          readonly schema: definitions["Error"];
        };
        /** Region already exists for that platform and location */
        readonly 409: {
          readonly schema: definitions["Error"];
        };
        /** Unexpected Error */
        readonly 500: {
          readonly schema: definitions["Error"];
        };
      };
    };
  };
  readonly "/regions/{id}": {
    readonly get: {
      readonly parameters: {
        readonly path: {
          /** ID of the region to lookup, stored as a base32 encoded 18 byte identifier. */
          readonly id: string;
        };
      };
      readonly responses: {
        /** A region. */
        readonly 200: {
          readonly schema: definitions["Region"];
        };
        /** Provided Region ID is Invalid */
        readonly 400: {
          readonly schema: definitions["Error"];
        };
        /** Region could not be found */
        readonly 404: {
          readonly schema: definitions["Error"];
        };
        /** Unexpected Error */
        readonly 500: {
          readonly schema: definitions["Error"];
        };
      };
    };
    readonly patch: {
      readonly parameters: {
        readonly path: {
          /** ID of the region to lookup, stored as a base32 encoded 18 byte identifier. */
          readonly id: string;
        };
        readonly body: {
          /** Region update request */
          readonly body: definitions["UpdateRegion"];
        };
      };
      readonly responses: {
        /** Complete region object */
        readonly 200: {
          readonly schema: definitions["Region"];
        };
        /** Invalid request provided */
        readonly 400: {
          readonly schema: definitions["Error"];
        };
        /** Unexpected Error */
        readonly 500: {
          readonly schema: definitions["Error"];
        };
      };
    };
  };
  readonly "/providers/": {
    readonly get: {
      readonly parameters: {
        readonly query: {
          /** Filter results to only include those that have this label. */
          readonly label?: parameters["LabelFilter"];
        };
      };
      readonly responses: {
        /** A list of providers. */
        readonly 200: {
          readonly schema: readonly definitions["Provider"][];
        };
        /** Unexpected Error */
        readonly 500: {
          readonly schema: definitions["Error"];
        };
      };
    };
    readonly post: {
      readonly parameters: {
        readonly body: {
          /** Provider create request */
          readonly body: definitions["CreateProvider"];
        };
      };
      readonly responses: {
        /** Complete provider object */
        readonly 201: {
          readonly schema: definitions["Provider"];
        };
        /** Invalid request provided */
        readonly 400: {
          readonly schema: definitions["Error"];
        };
        /** Forbidden */
        readonly 403: {
          readonly schema: definitions["Error"];
        };
        /** Provider already exists with that label */
        readonly 409: {
          readonly schema: definitions["Error"];
        };
        /** Unexpected Error */
        readonly 500: {
          readonly schema: definitions["Error"];
        };
      };
    };
  };
  readonly "/providers/{id}": {
    readonly get: {
      readonly parameters: {
        readonly path: {
          /** ID of the provider to lookup, stored as a base32 encoded 18 byte identifier. */
          readonly id: string;
        };
      };
      readonly responses: {
        /** A provider. */
        readonly 200: {
          readonly schema: definitions["Provider"];
        };
        /** Unknown provider error */
        readonly 404: {
          readonly schema: definitions["Error"];
        };
        /** Unexpected Error */
        readonly 500: {
          readonly schema: definitions["Error"];
        };
      };
    };
    readonly patch: {
      readonly parameters: {
        readonly path: {
          /** ID of the provider to update, stored as a base32 encoded 18 byte identifier. */
          readonly id: string;
        };
        readonly body: {
          /** Provider update request */
          readonly body: definitions["UpdateProvider"];
        };
      };
      readonly responses: {
        /** Complete provider object */
        readonly 200: {
          readonly schema: definitions["Provider"];
        };
        /** Invalid request provided */
        readonly 400: {
          readonly schema: definitions["Error"];
        };
        /** Forbidden */
        readonly 403: {
          readonly schema: definitions["Error"];
        };
        /** Provider not found */
        readonly 404: {
          readonly schema: definitions["Error"];
        };
        /** Provider already exists with that label */
        readonly 409: {
          readonly schema: definitions["Error"];
        };
        /** Unexpected Error */
        readonly 500: {
          readonly schema: definitions["Error"];
        };
      };
    };
  };
  readonly "/products/": {
    readonly get: {
      readonly parameters: {
        readonly query: {
          /**
           * Base32 encoded 18 byte identifier of the provider that these
           * products must belong to.
           */
          readonly provider_id?: string;
          /** Filter results to only include those that have this label. */
          readonly label?: parameters["LabelFilter"];
          /** Return only products matching at least one of the tags. */
          readonly tags?: readonly string[];
        };
      };
      readonly responses: {
        /** A product. */
        readonly 200: {
          readonly schema: readonly definitions["Product"][];
        };
        /** Invalid provider_id supplied */
        readonly 400: {
          readonly schema: definitions["Error"];
        };
        /** Unexpected Error */
        readonly 500: {
          readonly schema: definitions["Error"];
        };
      };
    };
    readonly post: {
      readonly parameters: {
        readonly body: {
          /** Product create request */
          readonly body: definitions["CreateProduct"];
        };
      };
      readonly responses: {
        /** Complete product object */
        readonly 201: {
          readonly schema: definitions["Product"];
        };
        /** Invalid request provided */
        readonly 400: {
          readonly schema: definitions["Error"];
        };
        /** Forbidden */
        readonly 403: {
          readonly schema: definitions["Error"];
        };
        /** Product already exists with that label */
        readonly 409: {
          readonly schema: definitions["Error"];
        };
        /** Unexpected Error */
        readonly 500: {
          readonly schema: definitions["Error"];
        };
      };
    };
  };
  readonly "/internal/products": {
    readonly get: {
      readonly parameters: {
        readonly query: {
          /**
           * Base32 encoded 18 byte identifier of the provider that these
           * products must belong to.
           */
          readonly provider_id?: string;
          /** Filter results to only include those that have this label. */
          readonly label?: parameters["LabelFilter"];
          /** Return only products matching at least one of the tags. */
          readonly tags?: readonly string[];
          /** Return product listings without plan information */
          readonly include_plans?: boolean;
        };
      };
      readonly responses: {
        /** A product. */
        readonly 200: {
          readonly schema: readonly definitions["ExpandedProduct"][];
        };
        /** Invalid provider_id supplied */
        readonly 400: {
          readonly schema: definitions["Error"];
        };
        /** Unexpected Error */
        readonly 500: {
          readonly schema: definitions["Error"];
        };
      };
    };
  };
  readonly "/products/{id}": {
    readonly get: {
      readonly parameters: {
        readonly path: {
          /**
           * ID of the product to lookup, stored as a base32 encoded 18 byte
           * identifier.
           */
          readonly id: string;
        };
      };
      readonly responses: {
        /** A product. */
        readonly 200: {
          readonly schema: definitions["Product"];
        };
        /** Invalid Product ID */
        readonly 400: {
          readonly schema: definitions["Error"];
        };
        /** Product not found error */
        readonly 404: {
          readonly schema: definitions["Error"];
        };
        /** Unexpected error */
        readonly 500: {
          readonly schema: definitions["Error"];
        };
      };
    };
    readonly patch: {
      readonly parameters: {
        readonly path: {
          /**
           * ID of the product to lookup, stored as a base32 encoded 18 byte
           * identifier.
           */
          readonly id: string;
        };
        readonly body: {
          /** Product update request */
          readonly body: definitions["UpdateProduct"];
        };
      };
      readonly responses: {
        /** Complete product object */
        readonly 200: {
          readonly schema: definitions["Product"];
        };
        /** Invalid Product ID */
        readonly 400: {
          readonly schema: definitions["Error"];
        };
        /** Product not found error */
        readonly 404: {
          readonly schema: definitions["Error"];
        };
        /** Unexpected error */
        readonly 500: {
          readonly schema: definitions["Error"];
        };
      };
    };
  };
  readonly "/plans/{id}": {
    readonly get: {
      readonly parameters: {
        readonly path: {
          /**
           * ID of the plan to lookup, stored as a base32 encoded 18 byte
           * identifier.
           */
          readonly id: string;
        };
      };
      readonly responses: {
        /** A plan. */
        readonly 200: {
          readonly schema: definitions["ExpandedPlan"];
        };
        /** Invalid Plan ID Provided */
        readonly 400: {
          readonly schema: definitions["Error"];
        };
        /** Unknown plan error */
        readonly 404: {
          readonly schema: definitions["Error"];
        };
        /** Unexpected error */
        readonly default: {
          readonly schema: definitions["Error"];
        };
      };
    };
    readonly patch: {
      readonly parameters: {
        readonly path: {
          /**
           * ID of the plan to lookup, stored as a base32 encoded 18 byte
           * identifier.
           */
          readonly id: string;
        };
        readonly body: {
          /** Plan update request */
          readonly body: definitions["UpdatePlan"];
        };
      };
      readonly responses: {
        /** Complete product plan */
        readonly 200: {
          readonly schema: definitions["Plan"];
        };
        /** Invalid Plan ID */
        readonly 400: {
          readonly schema: definitions["Error"];
        };
        /** Plan not found error */
        readonly 404: {
          readonly schema: definitions["Error"];
        };
        /** Unexpected error */
        readonly 500: {
          readonly schema: definitions["Error"];
        };
      };
    };
  };
  readonly "/plans/": {
    readonly get: {
      readonly parameters: {
        readonly query: {
          /** Return the plans that are associated with this product. */
          readonly product_id: readonly string[];
          /** Filter results to only include those that have this label. */
          readonly label?: parameters["LabelFilter"];
        };
      };
      readonly responses: {
        /** A list of plans for the given product. */
        readonly 200: {
          readonly schema: readonly definitions["ExpandedPlan"][];
        };
        /** Invalid Parameters Provided */
        readonly 400: {
          readonly schema: definitions["Error"];
        };
        /** Could not find product */
        readonly 404: {
          readonly schema: definitions["Error"];
        };
        /** Unexpected error */
        readonly 500: {
          readonly schema: definitions["Error"];
        };
      };
    };
    readonly post: {
      readonly parameters: {
        readonly body: {
          /** Plan create request */
          readonly body: definitions["CreatePlan"];
        };
      };
      readonly responses: {
        /** Complete plan object */
        readonly 201: {
          readonly schema: definitions["Plan"];
        };
        /** Invalid request provided */
        readonly 400: {
          readonly schema: definitions["Error"];
        };
        /** Forbidden */
        readonly 403: {
          readonly schema: definitions["Error"];
        };
        /** Plan already exists with that label */
        readonly 409: {
          readonly schema: definitions["Error"];
        };
        /** Unexpected Error */
        readonly 500: {
          readonly schema: definitions["Error"];
        };
      };
    };
  };
}

export interface definitions {
  /** A base32 encoded 18 byte identifier. */
  readonly ID: string;
  /** A base32 encoded 18 byte identifier. */
  readonly OptionalID: string;
  /** A flexible identifier for internal or external entities. */
  readonly FlexID: string;
  /** A flexible identifier for internal or external entities. */
  readonly OptionalFlexID: string;
  /** A machine readable unique label, which is url safe. */
  readonly Label: string;
  /** A machine readable unique label, which is url safe. */
  readonly OptionalLabel: string;
  /** A machine readable unique label, which is url safe. */
  readonly FeatureValueLabel: string;
  /** A location of where a potential resource can be provisioned. */
  readonly Location: string;
  /** A name of a platform which is used to provision resources. */
  readonly Platform: string;
  /** A name of an entity which is displayed to a human. */
  readonly Name: string;
  /** A name of an entity which is displayed to a human. */
  readonly OptionalName: string;
  /**
   * Logo used for Provider and Product listings.
   *
   * Must be square (same width and height) and minimum 400px. Maximum of 800px.
   */
  readonly LogoURL: string;
  /**
   * Logo used for Provider and Product listings.
   *
   * Must be square (same width and height) and minimum 400px. Maximum of 800px.
   */
  readonly OptionalLogoURL: string;
  readonly RegionBody: {
    readonly platform: definitions["Platform"];
    readonly location: definitions["Location"];
    readonly name: string;
    readonly priority: number;
  };
  readonly Region: {
    readonly id: definitions["ID"];
    readonly type: "region";
    readonly version: 1;
    readonly body: definitions["RegionBody"];
  };
  readonly CreateRegion: {
    readonly body: definitions["RegionBody"];
  };
  readonly UpdateRegion: {
    readonly name: string;
  };
  readonly ProviderBody: {
    readonly owner_id?: definitions["OptionalFlexID"];
    readonly team_id?: definitions["OptionalID"];
    readonly label: definitions["Label"];
    readonly name: definitions["Name"];
    readonly logo_url?: definitions["LogoURL"];
    readonly support_email?: string;
    readonly documentation_url?: string;
  };
  readonly UpdateProviderBody: {
    readonly owner_id?: definitions["OptionalFlexID"];
    readonly team_id?: definitions["OptionalID"];
    readonly label?: definitions["OptionalLabel"];
    readonly name?: definitions["OptionalName"];
    readonly logo_url?: definitions["OptionalLogoURL"];
    readonly support_email?: string;
    readonly documentation_url?: string;
  };
  readonly Provider: {
    readonly id: definitions["ID"];
    readonly version: 1;
    readonly type: "provider";
    readonly body: definitions["ProviderBody"];
  };
  readonly CreateProvider: {
    readonly body: definitions["ProviderBody"];
  };
  readonly UpdateProvider: {
    readonly id: definitions["ID"];
    readonly body: definitions["UpdateProviderBody"];
  };
  readonly UpdateProduct: {
    readonly id: definitions["ID"];
    readonly body: definitions["UpdateProductBody"];
  };
  readonly UpdateProductBody: {
    readonly name?: definitions["Name"];
    readonly label?: definitions["Label"];
    readonly logo_url?: definitions["LogoURL"];
    readonly listing?: definitions["ProductListing"];
    /** 140 character sentence positioning the product. */
    readonly tagline?: string;
    /** A list of value propositions of the product. */
    readonly value_props?: readonly definitions["ValueProp"][];
    /** A list of getting started steps for the product */
    readonly setup_steps?: readonly string[];
    readonly images?: readonly definitions["ProductImageURL"][];
    readonly support_email?: string;
    readonly documentation_url?: string;
    /**
     * URL to this Product's Terms of Service. If provided is true, then
     * a url must be set. Otherwise, provided is false.
     */
    readonly terms_url?: string;
    readonly feature_types?: readonly definitions["FeatureType"][];
    readonly integration?: {
      readonly provisioning?: definitions["ProductProvisioning"];
      readonly base_url?: string;
      readonly sso_url?: string;
      readonly version?: "v1";
      readonly features?: {
        readonly access_code?: boolean;
        readonly sso?: boolean;
        readonly plan_change?: boolean;
        readonly credential?: "none" | "single" | "multiple" | "unknown";
      };
    };
    /** An array of platform ids to restrict this product for. */
    readonly platform_ids?: readonly definitions["ID"][];
    readonly tags?: definitions["ProductTags"];
  };
  readonly UpdatePlan: {
    readonly id: definitions["ID"];
    readonly body: definitions["UpdatePlanBody"];
  };
  readonly UpdatePlanBody: {
    readonly name?: definitions["Name"];
    readonly label?: definitions["Label"];
    readonly state?: definitions["PlanState"];
    /** Used in conjuction with resizable_to to set or unset the list */
    readonly has_resize_constraints?: boolean;
    readonly resizable_to?: definitions["PlanResizeList"];
    /** Array of Region IDs */
    readonly regions?: readonly definitions["ID"][];
    /** Array of Feature Values */
    readonly features?: readonly definitions["FeatureValue"][];
    /**
     * The number of days a user gets as a free trial when subscribing to
     * this plan. Trials are valid only once per product; changing plans
     * or adding an additional subscription will not start a new trial.
     */
    readonly trial_days?: number;
    /** Dollar value in cents */
    readonly cost?: number;
  };
  /**
   * A feature type represents the different aspects of a product that are
   * offered, these features can manifest differently depending on the plan.
   */
  readonly FeatureType: {
    readonly label: definitions["Label"];
    readonly name: definitions["Name"];
    readonly type: "boolean" | "string" | "number";
    /** This sets whether or not the feature can be customized by a consumer. */
    readonly customizable?: boolean;
    /**
     * This sets whether or not the feature can be upgraded by the consumer after the
     * resource has provisioned. Upgrading means setting a higher value or selecting a
     * higher element in the list.
     */
    readonly upgradable?: boolean;
    /**
     * This sets whether or not the feature can be downgraded by the consumer after the
     * resource has provisioned. Downgrading means setting a lower value or selecting a
     * lower element in the list.
     */
    readonly downgradable?: boolean;
    /**
     * Sets if this feature’s value is trackable from the provider,
     * this only really affects numeric constraints.
     */
    readonly measurable?: boolean;
    readonly values?: definitions["FeatureValuesList"];
  };
  /**
   * A list of allowable values for the feature.
   * To define values for a boolean feature type, only `true` is required,
   * using the label `true`, name and numeric_details will be ignored.
   * If the feature is set measurable it is expected that these all have a
   * `numeric_details` definition, and the plan will determine which
   * `numeric_details` set is used based on it's setting.
   */
  readonly FeatureValuesList: readonly definitions["FeatureValueDetails"][];
  readonly FeatureValueDetails: {
    readonly label: definitions["FeatureValueLabel"];
    readonly name: definitions["Name"];
    /**
     * The cost that will be added to the monthly plan cost when this value
     * is selected or is default for the plan.
     * Cost is deprecated in favor of the `price.cost` field.
     */
    readonly cost?: number;
    /**
     * Price describes the cost of a feature. It should be preferred over
     * the `cost` property.
     */
    readonly price?: {
      /**
       * Cost is the price in cents that will be added to plan's base cost
       * when this value is selected or is default for the plan.
       * Number features should use the cost range instead.
       */
      readonly cost?: number;
      /**
       * When a feature is used to multiply the cost of the plan or of
       * another feature, multiply factor is used for calculation.
       * A feature cannot have both a cost and a multiply factor.
       */
      readonly multiply_factor?: number;
      /** Price describes how the feature cost should be calculated. */
      readonly formula?: definitions["PriceFormula"];
      /** Description explains how a feature is calculated to the user. */
      readonly description?: string;
    };
    readonly numeric_details?: definitions["FeatureNumericDetails"];
  };
  /**
   * Optional container for additional details relating to numeric features.
   * This is required if the feature is measurable and numeric.
   */
  readonly FeatureNumericDetails: {
    /**
     * Sets the increment at which numbers can be selected if customizable, by
     * default this is 1; for example, setting this to 8 would only allow integers
     * in increments of 8 ( 0, 8, 16, ... ). This property is not used if the
     * feature is measurable; except if it is set to 0, setting the increment to 0
     * means this numeric details has no scale, and will not be or customizable.
     * Some plans may not have a measureable or customizable feature.
     */
    readonly increment?: number;
    /** Minimum value that can be set by a user if customizable */
    readonly min?: number;
    /** Maximum value that can be set by a user if customizable */
    readonly max?: number;
    /** Applied to the end of the number for display, for example the ‘GB’ in ‘20 GB’. */
    readonly suffix?: string;
    readonly cost_ranges?: readonly definitions["FeatureNumericRange"][];
  };
  readonly FeatureNumericRange: {
    /**
     * Defines the end of the range ( inclusive ), from the previous, or 0;
     * where the cost_multiple starts taking effect. If set to -1 this defines the
     * range to infinity, or the maximum integer the system can handle
     * ( whichever comes first ).
     */
    readonly limit?: number;
    /**
     * An integer in 10,000,000ths of cents, will be multiplied by the
     * numeric value set in the feature to determine the cost.
     */
    readonly cost_multiple?: number;
  };
  readonly FeatureValue: {
    readonly feature: definitions["Label"];
    readonly value: definitions["FeatureValueLabel"];
  };
  readonly ValueProp: {
    /** Heading of a value proposition. */
    readonly header: string;
    /** Body of a value proposition. */
    readonly body: string;
  };
  /**
   * Image URL used for Product listings.
   *
   * Minimum 660px wide, 400px high.
   */
  readonly ProductImageURL: string;
  /** List of tags for product categorization and search */
  readonly ProductTags: readonly definitions["Label"][];
  readonly ProductState: "available" | "hidden" | "grandfathered" | "new" | "upcoming";
  readonly ProductListing: {
    /**
     * When true, everyone can see the product when requested. When false it will
     * not be visible to anyone except those on the provider team.
     */
    readonly public?: boolean;
    /**
     * When true, the product will be displayed in product listings alongside
     * other products. When false the product will be excluded from listings,
     * but can still be provisioned directly if it's label is known.
     * Any pages that display information about the product when not listed,
     * should indicate to webcrawlers that the content should not be indexed.
     */
    readonly listed?: boolean;
    /**
     * Object to hold various flags for marketing purposes only. These are values
     * that need to be stored, but should not affect decision making in code. If
     * we find ourselves in a position where we think they should, we should
     * consider refactoring our listing definition.
     */
    readonly marketing?: {
      /**
       * Indicates whether or not the product is in `Beta` and should be
       * advertised as such. This does not have any impact on who can access the
       * product, it is just used to inform consumers through our clients.
       */
      readonly beta?: boolean;
      /**
       * Indicates whether or not the product is in `New` and should be
       * advertised as such. This does not have any impact on who can access the
       * product, it is just used to inform consumers through our clients.
       */
      readonly new?: boolean;
      /**
       * Indicates whether or not the product is in `New` and should be
       * advertised as such. This does not have any impact on who can access the
       * product, it is just used to inform consumers through our clients.
       */
      readonly featured?: boolean;
    };
  };
  /**
   * Provider Only, implies that the product should only be provisionable by the
   *   provider; so members of the provider team, no one else should be allowed.
   * Pre-Order, should not be used yet. But in the future it should allow people to
   *   pre-provision a resource for when it does go live.
   * Public, means the resource is live and everyone should be able to provision it.
   */
  readonly ProductProvisioning: "provider-only" | "pre-order" | "public";
  readonly ProductIntegrationFeatures: {
    /**
     * Indicates whether or not this product supports resource transitions to
     * manifold by access_code.
     */
    readonly access_code?: boolean;
    /**
     * Represents whether or not this product supports Single
     * Sign On
     */
    readonly sso?: boolean;
    /**
     * Represents whether or not this product supports changing
     * the plan of a resource.
     */
    readonly plan_change?: boolean;
    /**
     * Describes how the region for a resource is specified, if
     * unspecified, then regions have no impact on this
     * resource.
     */
    readonly region?: "user-specified" | "unspecified";
    /**
     * Describes the credential type that is supported by this product.
     *
     * * `none`: The product does not support providing any credentials
     * * `single`: Only one credential is supported at the same time.
     * * `multiple`: Multiple credentials are supported at the same time.
     * * `unknown`: The credential type is unknown.
     */
    readonly credential?: "none" | "single" | "multiple" | "unknown";
  };
  readonly ProductBody: {
    readonly provider_id: definitions["ID"];
    /** Product labels are globally unique and contain the provider name. */
    readonly label: definitions["Label"];
    readonly name: definitions["Name"];
    readonly state: definitions["ProductState"];
    readonly listing: definitions["ProductListing"];
    readonly logo_url: definitions["LogoURL"];
    /** 140 character sentence positioning the product. */
    readonly tagline: string;
    /** A list of value propositions of the product. */
    readonly value_props: readonly definitions["ValueProp"][];
    /** A list of getting started steps for the product */
    readonly setup_steps?: readonly string[];
    readonly images: readonly definitions["ProductImageURL"][];
    readonly support_email: string;
    readonly documentation_url: string;
    /**
     * URL to this Product's Terms of Service. If provided is true, then
     * a url must be set. Otherwise, provided is false.
     */
    readonly terms: {
      readonly url?: string;
      readonly provided: boolean;
    };
    readonly feature_types: readonly definitions["FeatureType"][];
    readonly billing: {
      readonly type: "monthly-prorated" | "monthly-anniversary" | "annual-anniversary";
      readonly currency: "usd";
    };
    readonly integration: {
      readonly provisioning: definitions["ProductProvisioning"];
      readonly base_url: string;
      readonly sso_url?: string;
      readonly version: "v1";
      readonly features: definitions["ProductIntegrationFeatures"];
    };
    readonly tags?: definitions["ProductTags"];
  };
  readonly Product: {
    readonly id: definitions["ID"];
    readonly version: 1;
    readonly type: "product";
    readonly body: definitions["ProductBody"];
  };
  readonly CreateProduct: {
    readonly body: definitions["ProductBody"];
  };
  /** Array of Plan IDs that this Plan can be resized to, if null all will be assumed */
  readonly PlanResizeList: readonly definitions["ID"][];
  readonly PlanBody: {
    readonly provider_id: definitions["ID"];
    readonly product_id: definitions["ID"];
    readonly name: definitions["Name"];
    readonly label: definitions["Label"];
    readonly state: definitions["PlanState"];
    readonly resizable_to?: definitions["PlanResizeList"];
    /** Array of Region IDs */
    readonly regions: readonly definitions["ID"][];
    /** Array of Feature Values */
    readonly features: readonly definitions["FeatureValue"][];
    /**
     * The number of days a user gets as a free trial when subscribing to
     * this plan. Trials are valid only once per product; changing plans
     * or adding an additional subscription will not start a new trial.
     */
    readonly trial_days?: number;
    /** Dollar value in cents. */
    readonly cost: number;
  };
  readonly PlanState: "hidden" | "available" | "grandfathered" | "unlisted";
  readonly ExpandedPlanBody: definitions["PlanBody"] & {
    /** An array of feature definitions for the plan, as defined on the Product. */
    readonly expanded_features: readonly definitions["ExpandedFeature"][];
    /** A boolean flag that indicates if a plan is free or not based on it's cost and features. */
    readonly free: boolean;
    /** Plan cost using its default features plus base cost. */
    readonly defaultCost?: number;
    /** A boolean flag that indicates if a plan has customizable features. */
    readonly customizable?: boolean;
  };
  readonly ExpandedFeature: definitions["FeatureType"] & {
    /** The string value set for the feature on the plan, this should only be used if the value property is null. */
    readonly value_string: string;
    readonly value: definitions["FeatureValueDetails"];
  };
  readonly Plan: {
    readonly id: definitions["ID"];
    readonly version: 1;
    readonly type: "plan";
    readonly body: definitions["PlanBody"];
  };
  readonly ExpandedPlan: {
    readonly id: definitions["ID"];
    readonly version: 1;
    readonly type: "plan";
    readonly body: definitions["ExpandedPlanBody"];
  };
  readonly CreatePlan: {
    readonly body: definitions["PlanBody"];
  };
  /** Unexpected error */
  readonly Error: {
    /** The error type */
    readonly type: string;
    /** Explanation of the errors */
    readonly message: readonly string[];
  };
  /**
   * Describes how a feature cost should be calculated. An empty
   * string defaults to the normal price calculation using the value cost.
   * Formula uses Reverse Polish notation for statements. It supports
   * addition, subtraction and multiplication operations. Operations must be
   * grouped with parenthesis.
   * Number literals can be used for formulas. Eg: "(- feature-a#cost 500)"
   * will remove 5 dollars from the cost of feature a.
   * Multiplication operation supports either a cost multiplied by a
   * factor or a number multiplied by a factor.
   * In a plan formula the following keywords are available:
   *   - `plan#base_cost` is the base cost of a plan in cents
   *   - `plan#partial_cost` is the base cost plus its feature costs calculated
   *     so far. Feature formulas are calculated in the order they are defined,
   *     so features can refer to another feature values or the partial_cost of
   *     the plan.
   *   - `this-feature-label#multiply_factor` is the multiply_factor of this
   *     feature as a float number.
   *   - `another-feature-label#cost` is the cost of a feature matching the label
   *     in cents.
   *   - `another-feature-label#number` is the numeric value of a number feature
   * In a feature formula, plan base cost and total cost cannot be used
   */
  readonly PriceFormula: string;
  readonly ExpandedProduct: {
    readonly id: definitions["ID"];
    readonly version: 1;
    readonly type: "product";
    readonly body: definitions["ProductBody"];
    readonly plans?: readonly definitions["ExpandedPlan"][];
    readonly provider: definitions["Provider"];
  };
}

export interface parameters {
  /** Filter results to only include those that have this label. */
  readonly LabelFilter: string;
}

export interface operations {}

export interface external {}
